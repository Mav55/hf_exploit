import json
from web3 import Web3
from solcx import compile_files, install_solc
import os

# Load configuration
with open('config.json', 'r') as config_file:
    config = json.load(config_file)

project_id = config['project_id']
private_key = config['private_key']
contract_name = config['contract_name']

# Solidity compiler
install_solc('0.8.0')

# Connect to Infura Project
infura_url = f'https://sepolia.infura.io/v3/{project_id}'

# Connect to the Ethereum testnet
w3 = Web3(Web3.HTTPProvider(infura_url))

# Check connection
assert w3.isConnected(), "Failed to connect to Ethereum node"

# First Time Only: Generate a new Ethereum account
# account = w3.eth.account.create()

account = w3.eth.account.privateKeyToAccount(private_key)
w3.eth.defaultAccount = account.address

print(f"Account Address: {account.address}")

balance = w3.eth.get_balance(account.address)
print(f"Account Balance: {w3.fromWei(balance, 'ether')} ETH")

# Compile all contracts in the 'contracts' directory
contracts_path = './contracts'
contract_files = [os.path.join(contracts_path, f) for f in os.listdir(contracts_path) if f.endswith('.sol')]
compiled_contracts = compile_files(contract_files, output_values=['abi', 'bin'])

# Debug: Print compiled contract keys
print("Compiled Contracts Keys:")
for key in compiled_contracts.keys():
    print(key)


# Deploy function
def deploy_contract(web3_instance, compiled_contract_data, priv_key, tx_nonce):
    bytecode = compiled_contract_data['bin']
    abi = compiled_contract_data['abi']

    contract = web3_instance.eth.contract(abi=abi, bytecode=bytecode)

    # Estimate gas required for deployment
    gas_estimate = contract.constructor().estimateGas()

    # Get the current gas price from the network
    gas_price = web3_instance.eth.gas_price

    # Build the transaction
    transaction = contract.constructor().buildTransaction({
        'from': web3_instance.eth.defaultAccount,
        'nonce': tx_nonce,
        'gas': gas_estimate,
        'gasPrice': gas_price
    })

    # Sign the transaction
    signed_txn = web3_instance.eth.account.sign_transaction(transaction, priv_key)

    # Send the transaction
    tx_hash = web3_instance.eth.send_raw_transaction(signed_txn.rawTransaction)
    tx_receipt = web3_instance.eth.waitForTransactionReceipt(tx_hash)

    return tx_receipt.contractAddress


# Normalize path for consistent key format
def normalize_path(path):
    return os.path.relpath(path, start='.').replace('\\', '/')


# Deploy contracts
with open('deployed_contracts.txt', 'a') as f:
    for contract_file in contract_files:
        normalized_path = normalize_path(contract_file)
        key = f'{normalized_path}:{contract_name}'
        if key in compiled_contracts:
            compiled_contract = compiled_contracts[key]
            while True:
                try:
                    nonce = w3.eth.getTransactionCount(account.address)
                    contract_address = deploy_contract(w3, compiled_contract, private_key, nonce)
                    f.write(f"{normalized_path}: {contract_address}\n")
                    f.flush()
                    print(f"Deployed {normalized_path} at {contract_address}")
                    break
                except ValueError as e:
                    print(f"Error deploying {normalized_path}: {str(e)}")
                    if 'already known' in str(e):
                        # Increment nonce if transaction is already known
                        continue
                    elif 'underpriced' in str(e):
                        # Increase gas price and retry deployment
                        print("Increasing gas price and re-attempting deployment...")
                        continue
                    else:
                        # Handle other errors as needed
                        print("Encountered unexpected error. Exiting.")
                        break
        else:
            print(f"Error: Key {key} not found in compiled contracts")

print("Deployment completed, addresses saved to deployed_contracts.txt")

