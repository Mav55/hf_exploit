import json
from web3 import Web3
from eth_utils import remove_0x_prefix
from difflib import SequenceMatcher  # Import for text similarity comparison

# Load configuration
try:
    with open('config.json', 'r') as config_file:
        config = json.load(config_file)
    project_id = config['project_id']
except FileNotFoundError:
    print("Config file 'config.json' not found.")
    exit(1)
except KeyError:
    print("Invalid or missing 'project_id' in config.json.")
    exit(1)

# Connect to Infura Project
infura_url = f'https://sepolia.infura.io/v3/{project_id}'
try:
    w3 = Web3(Web3.HTTPProvider(infura_url))
    assert w3.isConnected(), "Failed to connect to Ethereum node"
    print(f"Connected to network")
except AssertionError as e:
    print(e)
    exit(1)


def normalize_bytecode(bytecode):
    """Normalize bytecode by removing the appended metadata."""
    if len(bytecode) > 2 and bytecode[:2] == '0x':
        bytecode = remove_0x_prefix(bytecode)
    # Find the start of the metadata
    metadata_start = bytecode.find('a165627a7a72305820')
    if metadata_start != -1:
        bytecode = bytecode[:metadata_start]
    return bytecode


def fetch_deployed_contracts(contract_addresses):
    """Fetch deployed contracts from the blockchain."""
    contracts = {}
    for address in contract_addresses:
        try:
            bytecode = w3.eth.getCode(address).hex()
            if bytecode == '0x':
                print(f"No bytecode found for {address}")
            else:
                bytecode = normalize_bytecode(bytecode)
                print(f"Fetched bytecode for {address}: {bytecode[:10]}...")
            contracts[address] = bytecode
        except Exception as e:
            print(f"Failed to fetch bytecode for {address}: {str(e)}")
    return contracts


def detect_duplicate_contracts():
    duplicate_contracts = []

    # Read deployed contract addresses from file
    try:
        with open('deployed_contracts.txt', 'r') as f:
            contract_addresses = [line.strip().split(": ")[1] for line in f.readlines()]
    except FileNotFoundError:
        print("File 'deployed_contracts.txt' not found.")
        exit(1)
    except IndexError:
        print("Invalid format in 'deployed_contracts.txt'. Expected format: 'Contract Name: Address'.")
        exit(1)

    # Fetch deployed contracts
    contracts = fetch_deployed_contracts(contract_addresses)

    # Compare bytecode of each pair of contracts
    contract_list = list(contracts.items())
    for i in range(len(contract_list)):
        address1, bytecode1 = contract_list[i]
        if bytecode1 is None:
            continue
        for j in range(i + 1, len(contract_list)):
            address2, bytecode2 = contract_list[j]
            if bytecode2 is None:
                continue
            # Compare bytecode once metadata is removed
            normalized_bytecode1 = normalize_bytecode(bytecode1)
            normalized_bytecode2 = normalize_bytecode(bytecode2)

            # Use SequenceMatcher to get a percentage of probability
            matcher = SequenceMatcher(None, normalized_bytecode1, normalized_bytecode2)
            match_probability = matcher.ratio()

            if match_probability > 0.99:
                duplicate_contracts.append((address1, address2))

    return duplicate_contracts


# Detect duplicate contracts
duplicates = detect_duplicate_contracts()

if duplicates:
    print("Duplicate Contracts Detected:")
    for addr1, addr2 in duplicates:
        print(f"Duplicate contracts: {addr1} and {addr2}")
else:
    print("No duplicate contracts found.")
