from solcx import compile_standard, install_solc
import hashlib
import os

# Install the Solidity compiler version you need
install_solc('0.8.0')


# Function to calculate the hash of bytecode
def calculate_hash(bytecode):
    return hashlib.sha256(bytecode.encode('utf-8')).hexdigest()


# Compile all contracts in the specified directory
contracts_path = './contracts'
contract_files = [os.path.join(contracts_path, f) for f in os.listdir(contracts_path) if f.endswith('.sol')]
sources = {os.path.basename(f): {'content': open(f, 'r').read()} for f in contract_files}

compiled_contracts = compile_standard({
    'language': 'Solidity',
    'sources': sources,
    'settings': {
        'optimizer': {
            'enabled': True,
            'runs': 200
        },
        'outputSelection': {
            '*': {
                '*': ['evm.bytecode.object', 'abi']
            }
        },
        'metadata': {
            'bytecodeHash': 'none'  # Exclude metadata from the bytecode hash
        }
    }
})

# Dictionary to store bytecode hashes and their corresponding contract names
bytecode_hashes = {}

# Extract bytecodes and calculate hashes for each contract
for file_name, compiled_contract in compiled_contracts['contracts'].items():
    contract_name = list(compiled_contract.keys())[0]
    bytecode = compiled_contract[contract_name]['evm']['bytecode']['object']
    bytecode_hash = calculate_hash(bytecode)

    if bytecode_hash in bytecode_hashes:
        bytecode_hashes[bytecode_hash].append(file_name)
    else:
        bytecode_hashes[bytecode_hash] = [file_name]

# Detect and print duplicate contracts
duplicate_detected = False
for bytecode_hash, contracts in bytecode_hashes.items():
    if len(contracts) > 1:
        duplicate_detected = True
        print(f"Duplicate contracts detected for hash {bytecode_hash}:")
        for contract in contracts:
            print(f"- {contract}")

if not duplicate_detected:
    print("No duplicate contracts found.")
